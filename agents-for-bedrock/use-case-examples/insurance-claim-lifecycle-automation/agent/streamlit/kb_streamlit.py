import io
import os
import re
import json
import time
import boto3
import base64
import PyPDF2
import string
import random

#import mammoth
from docx import Document

import pdfplumber
import pandas as pd
import streamlit as st
from docx import Document
from requests import request
from sigv4 import SigV4HttpRequester

# Bedrock Variable
knowledgeBaseId = os.environ['BEDROCK_KB_ID']
dataSourceId = os.environ['BEDROCK_DS_ID']
region = os.environ['AWS_REGION']

# Other Resource Variables
knowledge_base_s3_bucket = os.environ['KB_BUCKET_NAME']

# AWS Session and Clients Instantiation
session = boto3.Session(region_name=os.environ['AWS_REGION'])
agent_client = session.client('bedrock-agent')
agent_runtime_client = session.client('bedrock-agent-runtime')
s3_client = session.client('s3')

# Streamlit CSS
custom_css = """
    <style>
        .text-with-bg {
        color: white;
            background-color: #1c2e4a; /* Change this to your desired background color */
            padding: 10px;
            border-radius: 5px;
        }
    </style>
"""

# Streamlit App Layout
st.title('Bedrock Insurance Agent')
st.subheader('Powered by coffee and Amazon Bedrock')
st.info("**DISCLAIMER:** This demo uses an Amazon Bedrock foundation model and is not intended to collect any personally identifiable information (PII) from users. Please do not provide any PII when interacting with this demo. The content generated by this demo is for informational purposes only.")
idp_logo = "bedrock_logo.png"
st.sidebar.image(idp_logo, width=300, output_format='PNG')
st.sidebar.markdown(custom_css, unsafe_allow_html=True)
st.sidebar.subheader('**About this Demo**')
st.sidebar.markdown('<p class="text-with-bg">The Bedrock Insurance Solution uses Agents and Knowledge base for Amazon Bedrock to assist human insurance agents by creating new claims, sending pending document reminders and gathering evidence for claims, and providing access to claims data, repair estimates, FAQs, and other insurance documents. </p>', unsafe_allow_html=True)

def session_generator():
    # Generate random characters and digits
    digits = ''.join(random.choice(string.digits) for _ in range(4))  # Generating 4 random digits
    chars = ''.join(random.choice(string.ascii_lowercase) for _ in range(3))  # Generating 3 random characters
    
    # Construct the pattern (1a23b-4c)
    pattern = f"{digits[0]}{chars[0]}{digits[1:3]}{chars[1]}-{digits[3]}{chars[2]}"
    print("Session ID: " + str(pattern))

    return pattern

# Update the existing function
def bedrock_query_knowledge_base(query):
    # API endpoint for querying the knowledge base
    kb_url = f"https://bedrock-agent-runtime.{region}.amazonaws.com/knowledgebases/{knowledgeBaseId}/retrieveAndGenerate"
    
    # Construct the prompt template
    prompt_template = """\n\nHuman: You will be acting as a helpful customer service rep named Joe working for Pacific Life. You will be replying to users who are calling Pacific Life call center who will be confused if you don't respond in the character of Joe. Provide a summarized answer only using 1 or 2 sentences. 
    Here is the relevant information from our knowledge base: $search_results$
    User query: $query$\n\nAssistant: """

    # Construct the payload
    payload = {
        "input": {
            "text": query
        },
        "retrieveAndGenerateConfiguration": {
            "knowledgeBaseConfiguration": {
                "knowledgeBaseId": knowledgeBaseId,
                "modelArn": "anthropic.claude-v2:1",
                "generationConfiguration": {
                    "promptTemplate": {
                        "textPromptTemplate": prompt_template
                    }
                },
                "retrievalConfiguration": {
                    "vectorSearchConfiguration": {
                        "numberOfResults": 5  # Example setting, adjust as needed
                    }
                }
            },
            "type": "KNOWLEDGE_BASE"
        }
    }

    # "sessionId": session_generator()  # Generate session ID dynamically

    # send request
    print(f"Knowledge Base query: {query}")

    try:
        response = agent_runtime_client.retrieve_and_generate(**payload)
        retrieval_results = response.get("retrievalResults", [])

        print(f"response: {response}")

        # Extract the relevant information from the response
        if 'output' in response:
            kb_response = response['output']['text']
            
            # Split the text by newlines and select the desired part
            output_lines = kb_response.split('\n')
            clean_response = output_lines[-1].strip()  # Select the last line and remove leading/trailing whitespaces
            
            return clean_response  # Return the desired text

        else:
            return "No relevant information found in the knowledge base."

    except Exception as e:
        return f"Error querying knowledge base: {e}"

def update_knowledge_base(file_content, bucket_name, s3_file_name):
    print("Syncing Knowledge Base Data Source")

    try:
        # Wrap the bytes content in an in-memory file-like object
        file_obj = io.BytesIO(file_content)

        s3_client.upload_fileobj(file_obj, bucket_name, s3_file_name)
        st.success(f"File uploaded successfully to S3 bucket '{bucket_name}' as '{s3_file_name}'")
    except Exception as e:
        st.error(f"Error uploading file to S3: {e}")
        return

    # Start ingestion job
    description = "Programmatic update of Bedrock Knowledge Base Data Source"
    try:
        response = agent_client.start_ingestion_job(
            dataSourceId=dataSourceId,
            description=description,
            knowledgeBaseId=knowledgeBaseId
        )

    except Exception as e:
        st.error(f"Error starting ingestion job: {e}")
    finally:
        file_obj.close()  # Close the file-like object after upload

def check_ingestion_job_status():
    headers = {
        "Content-type": "application/json",
        # Add any necessary headers here
    }

    status = ""
    while status != "complete":
        try:
            response = agent_client.list_ingestion_jobs(
                knowledgeBaseId=knowledgeBaseId,
                dataSourceId=dataSourceId,
            )
            
            if response['ResponseMetadata']['HTTPStatusCode'] == 200:
                job_status = response["ingestionJobSummaries"][0]["status"]
                print(f"Ingestion Job Status: {job_status}")
                st.write(f"Ingestion Job Status: {job_status}")
                
                if job_status == "COMPLETE":
                    break
            else:
                st.write(f"Error: {response.status_code} - {response.text}")
        except Exception as e:
            st.write(f"An error occurred: {e}")

        time.sleep(4)  # Poll every 4 seconds (adjust as needed)

def show_csv(uploaded_file):
    # Display CSV preview
    st.subheader("CSV Preview")
    df = pd.read_csv(uploaded_file)
    st.write(df)

def extract_text_from_docx(uploaded_file):
    try:
        document = Document(uploaded_file)
        text = ""
        for paragraph in document.paragraphs:
            text += paragraph.text + "\n"
        return text
    except Exception as e:
        st.error(f"Error extracting text from .doc(x) file: {e}")
        return None

def convert_docx_to_html(docx_content):
    try:
        # Use python-docx to extract text from the DOCX content
        document = Document(io.BytesIO(docx_content))
        text = "\n".join([paragraph.text for paragraph in document.paragraphs])

        # Convert text to HTML
        html_content = f"<p>{text}</p>"
        return html_content
    except Exception as e:
        st.error(f"Error converting .docx to HTML: {e}")
        return None

def show_doc(uploaded_file):
    # Display content of .doc files
    st.subheader("Document Preview")
    text = extract_text_from_docx(uploaded_file)
    if text:
        st.write(text)
    else:
        st.error("Uploaded file is not a valid Word document.")

def show_docx(uploaded_file):
    # Display content of .docx files
    st.subheader("Document Preview")
    file_name = uploaded_file.name.lower()

    if 'docx' in file_name:
        # Read the content of the uploaded file
        docx_content = uploaded_file.getvalue()

        # For .docx files, convert to HTML for preview
        html_result = convert_docx_to_html(docx_content)
        if html_result:
            st.markdown(html_result, unsafe_allow_html=True)  # Display HTML content
        else:
            st.error("Failed to convert .docx to HTML")

def show_excel(uploaded_file):
    # Display Excel preview
    try:
        df = pd.read_excel(uploaded_file)
        st.subheader("Excel Preview")
        st.write(df)
    except Exception as e:
        st.error(f"Error reading Excel file: {e}")

def show_html(uploaded_file):
    st.subheader("HTML Preview")
    html_content = uploaded_file.getvalue().decode("utf-8")
    st.markdown(html_content, unsafe_allow_html=True)

def show_md(uploaded_file):
    # Display Markdown preview
    st.subheader("Markdown Preview")
    md_content = uploaded_file.getvalue().decode("utf-8")
    st.markdown(md_content)

def show_pdf(uploaded_file):
    # Display PDF preview
    st.subheader("PDF Preview")
    pdf_display = f'<iframe src="data:application/pdf;base64,{base64.b64encode(uploaded_file.read()).decode("utf-8")}" width="100%" height="500"></iframe>'
    st.markdown(pdf_display, unsafe_allow_html=True)

def show_text(uploaded_file):
    #Display Text preview
    text = uploaded_file.getvalue().decode("utf-8")
    st.subheader("Text Preview")
    st.write(text)

def process_uploaded_file(uploaded_file):
    file_name = uploaded_file.name.lower()
    file_extension = file_name.split(".")[-1]

    file_contents = None

    if file_extension == "csv":
        show_csv(uploaded_file)
        file_contents = uploaded_file.getvalue()

    elif file_extension == "doc":
        show_doc(uploaded_file)
        doc_content = extract_text_from_docx(uploaded_file)
        file_contents = doc_content.encode("utf-8") if doc_content else None

    elif file_extension == "docx":
        show_docx(uploaded_file)
        docx_content = extract_text_from_docx(uploaded_file)
        file_contents = docx_content.encode("utf-8") if docx_content else None

    elif file_extension in ["htm", "html"]:
        show_html(uploaded_file)
        html_content = uploaded_file.getvalue().decode("utf-8")
        file_contents = html_content.encode("utf-8") if html_content else None

    elif file_extension == "md":
        show_md(uploaded_file)
        md_content = uploaded_file.getvalue().decode("utf-8")
        file_contents = md_content.encode("utf-8") if md_content else None

    elif file_extension == "pdf":
        show_pdf(uploaded_file)
        file_contents = uploaded_file.getvalue()

    elif file_extension == "txt":
        show_text(uploaded_file)
        file_contents = uploaded_file.getvalue()

    elif file_extension in ["xls", "xlsx"]:
        show_excel(uploaded_file)
        file_contents = uploaded_file.getvalue()

    else:
        # Unsupported file type
        st.error("Preview not available for this file type.")

    return file_contents


def main():

    # Initialize session variables if not present
    if not "valid_inputs_received" in st.session_state:
        st.session_state["valid_inputs_received"] = False

    if "uploaded_files" not in st.session_state:
        st.session_state["uploaded_files"] = []

    # --- KB Q&A ---
    st.subheader('Knowledge Base for Amazon Bedrock - Prompt Input')
    query = st.text_input("User Input", value="", placeholder="What can the agent help you with?", label_visibility="visible")
    kb_response = None
    
    if st.session_state.get("previous_query") != query and query != "":
        if "session_id" not in st.session_state:
            st.session_state["session_id"] = session_generator()

        sessionId = st.session_state["session_id"]
        kb_response = bedrock_query_knowledge_base(query)
        st.session_state["previous_query"] = query  # Update previous_query if query changes

    if kb_response is not None:
        st.write("Knowledge Base Response:", kb_response)

    # --- Knowledge Base Update ---
    st.subheader("Knowledge Base for Amazon Bedrock - File Upload")
    uploaded_files = st.file_uploader("Upload Document", type=["csv", "doc", "docx", "htm", "html", "md", "pdf", "txt", "xls", "xlsx"], accept_multiple_files=True)

    if uploaded_files is not None:
        for uploaded_file in uploaded_files:
            if uploaded_file not in st.session_state["uploaded_files"]:
                st.session_state["uploaded_files"].append(uploaded_file)

                file_name = "agent/knowledge-base-assets/" + uploaded_file.name
                file_contents = process_uploaded_file(uploaded_file)
                update_knowledge_base(file_contents, knowledge_base_s3_bucket, file_name)
                check_ingestion_job_status()

# Call the main function to run the app
if __name__ == "__main__":
    main()