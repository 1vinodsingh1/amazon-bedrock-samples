import io
import os
import re
import json
import time
import boto3
import base64
import PyPDF2
import string
import random
from docx import Document
import pdfplumber
import pandas as pd
import streamlit as st
from docx import Document
from requests import request
from sigv4 import SigV4HttpRequester

# Other Resource Variables
knowledge_base_s3_bucket = os.environ['KB_BUCKET_NAME']
data_source_id = os.environ['BEDROCK_DS_ID']
region = os.environ['AWS_REGION']

# AWS Session and Clients Instantiation
session = boto3.Session(region_name=os.environ['AWS_REGION'])
agent_client = session.client('bedrock-agent')
agent_runtime_client = session.client('bedrock-agent-runtime')
s3_client = session.client('s3')

# Define possible knowledge base IDs, model IDs, & filter attributes
model_id_list = ["anthropic.claude-v2:1", "anthropic.claude-3-sonnet-20240229-v1:0", "anthropic.claude-3-haiku-20240307-v1:0"]
kb_id_list = ["ADYFKM2XKD", "CGRKKCOHAA"]
filter_attributes = ["None", "external", "internal"]

# Streamlit App Layout
st.title('Bedrock Insurance Agent')
st.subheader('Powered by coffee and Amazon Bedrock')
st.info("**DISCLAIMER:** This demo uses an Amazon Bedrock foundation model and is not intended to collect any personally identifiable information (PII) from users. Please do not provide any PII when interacting with this demo. The content generated by this demo is for informational purposes only.")
idp_logo = "bedrock_logo.png"
st.sidebar.image(idp_logo, width=300, output_format='PNG')

# Dropdowns for selecting knowledge base and model IDs
st.sidebar.subheader('Knowledge Base and Model IDs')
kb_id = st.sidebar.selectbox("Select Knowledge Base ID", kb_id_list)
model_id = st.sidebar.selectbox("Select Model ID", model_id_list)
model_arn = f"arn:aws:bedrock:{region}::foundation-model/{model_id}"
filter_attribute = st.sidebar.selectbox("Select Filter Attribute", filter_attributes)

# Initialize session variables if not present
if "session_id" not in st.session_state:
    st.session_state["session_id"] = None

if "session_enabled" not in st.session_state:
    st.session_state["session_enabled"] = False

# Enable Session radio button
st.sidebar.radio("Enable Session", [False, True], key="session_enabled")

# User choice: Agent or Knowledge Base
use_agent = st.sidebar.radio("Use Agent or Knowledge Base", ["Agent", "Knowledge Base"])

# Helper methods
def show_csv(uploaded_file):
    st.subheader("CSV Preview")
    df = pd.read_csv(uploaded_file)
    st.write(df)

def extract_text_from_docx(uploaded_file):
    try:
        document = Document(uploaded_file)
        text = ""
        for paragraph in document.paragraphs:
            text += paragraph.text + "\n"
        return text
    except Exception as e:
        st.error(f"Error extracting text from .doc(x) file: {e}")
        return None

def convert_docx_to_html(docx_content):
    try:
        document = Document(io.BytesIO(docx_content))
        text = "\n".join([paragraph.text for paragraph in document.paragraphs])
        html_content = f"<p>{text}</p>"
        return html_content
    except Exception as e:
        st.error(f"Error converting .docx to HTML: {e}")
        return None

def show_doc(uploaded_file):
    st.subheader("Document Preview")
    text = extract_text_from_docx(uploaded_file)
    if text:
        st.write(text)
    else:
        st.error("Uploaded file is not a valid Word document.")

def show_docx(uploaded_file):
    st.subheader("Document Preview")
    file_name = uploaded_file.name.lower()
    if 'docx' in file_name:
        docx_content = uploaded_file.getvalue()
        html_result = convert_docx_to_html(docx_content)
        if html_result:
            st.markdown(html_result, unsafe_allow_html=True)
        else:
            st.error("Failed to convert .docx to HTML")

def show_excel(uploaded_file):
    try:
        df = pd.read_excel(uploaded_file)
        st.subheader("Excel Preview")
        st.write(df)
    except Exception as e:
        st.error(f"Error reading Excel file: {e}")

def show_html(uploaded_file):
    st.subheader("HTML Preview")
    html_content = uploaded_file.getvalue().decode("utf-8")
    st.markdown(html_content, unsafe_allow_html=True)

def show_md(uploaded_file):
    st.subheader("Markdown Preview")
    md_content = uploaded_file.getvalue().decode("utf-8")
    st.markdown(md_content)

def show_pdf(uploaded_file):
    st.subheader("PDF Preview")
    pdf_display = f'<iframe src="data:application/pdf;base64,{base64.b64encode(uploaded_file.read()).decode("utf-8")}" width="100%" height="500"></iframe>'
    st.markdown(pdf_display, unsafe_allow_html=True)

def show_text(uploaded_file):
    text = uploaded_file.getvalue().decode("utf-8")
    st.subheader("Text Preview")
    st.write(text)

def process_uploaded_file(uploaded_file):
    file_name = uploaded_file.name.lower()
    file_extension = file_name.split(".")[-1]
    file_contents = None

    if file_extension == "csv":
        show_csv(uploaded_file)
        file_contents = uploaded_file.getvalue()

    elif file_extension == "doc":
        show_doc(uploaded_file)
        doc_content = extract_text_from_docx(uploaded_file)
        file_contents = doc_content.encode("utf-8") if doc_content else None

    elif file_extension == "docx":
        show_docx(uploaded_file)
        docx_content = extract_text_from_docx(uploaded_file)
        file_contents = docx_content.encode("utf-8") if docx_content else None

    elif file_extension in ["htm", "html"]:
        show_html(uploaded_file)
        html_content = uploaded_file.getvalue().decode("utf-8")
        file_contents = html_content.encode("utf-8") if html_content else None

    elif file_extension == "md":
        show_md(uploaded_file)
        md_content = uploaded_file.getvalue().decode("utf-8")
        file_contents = md_content.encode("utf-8") if md_content else None

    elif file_extension == "pdf":
        show_pdf(uploaded_file)
        file_contents = uploaded_file.getvalue()

    elif file_extension == "txt":
        show_text(uploaded_file)
        file_contents = uploaded_file.getvalue()

    elif file_extension in ["xls", "xlsx"]:
        show_excel(uploaded_file)
        file_contents = uploaded_file.getvalue()

    else:
        st.error("Preview not available for this file type.")

    return file_contents

def bedrock_query_knowledge_base(query):
    print(f"Knowledge Base query: {query}")

    prompt_template = """\n\nHuman: You will be acting as a helpful customer service representative named Ava (short for Amazon Virtual Assistant) working for AnyCompany. Provide a summarized answer using only 1 or 2 sentences. 
    Here is the relevant information in numbered order from our knowledge base: $search_results$
    Current time: $current_time$
    User query: $query$\n\nAssistant: """

    payload = {
        "input": {
            "text": query
        },
        "retrieveAndGenerateConfiguration": {
            "type": "KNOWLEDGE_BASE",
            "knowledgeBaseConfiguration": {
                "generationConfiguration": {
                    "promptTemplate": {
                        "textPromptTemplate": prompt_template
                    }
                },
                "knowledgeBaseId": kb_id,
                "modelArn": model_arn,
                "retrievalConfiguration": {
                    "vectorSearchConfiguration": {
                        "numberOfResults": 5,
                    }
                }
            }
        }
    }

    if filter_attribute != "None":
        print(f"filter_attribute: {filter_attribute}")
        payload["retrieveAndGenerateConfiguration"]["knowledgeBaseConfiguration"]["retrievalConfiguration"] = {
            "vectorSearchConfiguration": {
                "numberOfResults": 5,
                "filter": {
                    "equals": {
                        "key": "exposure",
                        "value": filter_attribute
                    }
                }
            }
        }

    if st.session_state.get("session_enabled", True):
        if st.session_state["session_id"] != None:
            sesh = st.session_state["session_id"]
            print(f"session_id: {sesh}")
            payload["sessionId"] = st.session_state["session_id"]

    try:
        print(f"payload: {payload}")
        response = agent_runtime_client.retrieve_and_generate(**payload)
        st.session_state["session_id"] = response.get("sessionId", st.session_state["session_id"])
        retrieval_results = response.get("retrievalResults", [])

        if 'output' in response:
            kb_response = response['output']['text']
            output_lines = kb_response.split('\n')
            clean_response = output_lines[-1].strip()
            return clean_response
        else:
            return "No relevant information found in the knowledge base."

    except Exception as e:
        return f"Error querying knowledge base: {e}"

def update_knowledge_base(file_content, bucket_name, s3_file_name):
    print("Syncing Knowledge Base Data Source")

    try:
        file_obj = io.BytesIO(file_content)
        s3_client.upload_fileobj(file_obj, bucket_name, s3_file_name)
        st.success(f"File uploaded successfully to S3 bucket '{bucket_name}' as '{s3_file_name}'")
    except Exception as e:
        st.error(f"Error uploading file to S3: {e}")
        return

    description = "Programmatic update of Bedrock Knowledge Base Data Source"
    try:
        response = agent_client.start_ingestion_job(
            dataSourceId=data_source_id,
            description=description,
            knowledgeBaseId=kb_id
        )
    except Exception as e:
        st.error(f"Error starting ingestion job: {e}")
    finally:
        file_obj.close()

def check_ingestion_job_status():
    headers = {
        "Content-type": "application/json",
    }

    status = ""
    while status != "complete":
        try:
            response = agent_client.list_ingestion_jobs(
                knowledgeBaseId=kb_id,
                dataSourceId=data_source_id,
            )
            
            if response['ResponseMetadata']['HTTPStatusCode'] == 200:
                job_status = response["ingestionJobSummaries"][0]["status"]
                print(f"Ingestion Job Status: {job_status}")
                st.write(f"Ingestion Job Status: {job_status}")
                
                if job_status == "COMPLETE":
                    break
            else:
                st.write(f"Error: {response.status_code} - {response.text}")
        except Exception as e:
            st.write(f"An error occurred: {e}")

        time.sleep(4)

def invoke_agent(query):
    print(f"Agent query: {query}")

    prompt_template = """\n\nHuman: You will be acting as a helpful customer service representative named Ava (short for Amazon Virtual Assistant) working for AnyCompany. Provide a summarized answer using only 1 or 2 sentences. 
    Here is the relevant information in numbered order from our knowledge base: $search_results$
    Current time: $current_time$
    User query: $query$\n\nAssistant: """

    payload = {
        "input": {
            "text": query
        },
        "retrieveAndGenerateConfiguration": {
            "type": "AGENT",
            "agentConfiguration": {
                "generationConfiguration": {
                    "promptTemplate": {
                        "textPromptTemplate": prompt_template
                    }
                },
                "modelArn": model_arn,
                "retrievalConfiguration": {
                    "vectorSearchConfiguration": {
                        "numberOfResults": 5,
                    }
                }
            }
        }
    }

    if filter_attribute != "None":
        print(f"filter_attribute: {filter_attribute}")
        payload["retrieveAndGenerateConfiguration"]["agentConfiguration"]["retrievalConfiguration"] = {
            "vectorSearchConfiguration": {
                "numberOfResults": 5,
                "filter": {
                    "equals": {
                        "key": "exposure",
                        "value": filter_attribute
                    }
                }
            }
        }

    if st.session_state.get("session_enabled", True):
        if st.session_state["session_id"] != None:
            sesh = st.session_state["session_id"]
            print(f"session_id: {sesh}")
            payload["sessionId"] = st.session_state["session_id"]

    try:
        print(f"payload: {payload}")
        response = agent_runtime_client.retrieve_and_generate(**payload)
        st.session_state["session_id"] = response.get("sessionId", st.session_state["session_id"])
        retrieval_results = response.get("retrievalResults", [])

        if 'output' in response:
            agent_response = response['output']['text']
            output_lines = agent_response.split('\n')
            clean_response = output_lines[-1].strip()
            return clean_response
        else:
            return "No relevant information found."

    except Exception as e:
        return f"Error invoking agent: {e}"

def main():
    if not "valid_inputs_received" in st.session_state:
        st.session_state["valid_inputs_received"] = False

    if "uploaded_files" not in st.session_state:
        st.session_state["uploaded_files"] = []

    st.subheader('Knowledge Base for Amazon Bedrock - Prompt Input')
    query = st.text_input("User Input", value="", placeholder="What can the agent help you with?", label_visibility="visible")
    response = None
    
    if st.session_state.get("previous_query") != query and query != "":
        if use_agent == "Agent":
            response = invoke_agent(query)
        else:
            response = bedrock_query_knowledge_base(query)
        
        st.session_state["previous_query"] = query

    if response is not None:
        st.write("Response:", response)

    st.subheader("Knowledge Base for Amazon Bedrock - File Upload")
    uploaded_files = st.file_uploader("Upload Document", type=["csv", "doc", "docx", "htm", "html", "md", "pdf", "txt", "xls", "xlsx"], accept_multiple_files=True)

    if uploaded_files is not None:
        for uploaded_file in uploaded_files:
            if uploaded_file not in st.session_state["uploaded_files"]:
                st.session_state["uploaded_files"].append(uploaded_file)
                file_name = "agent/knowledge-base-assets/" + uploaded_file.name
                file_contents = process_uploaded_file(uploaded_file)
                update_knowledge_base(file_contents, knowledge_base_s3_bucket, file_name)
                check_ingestion_job_status()

if __name__ == "__main__":
    main()
