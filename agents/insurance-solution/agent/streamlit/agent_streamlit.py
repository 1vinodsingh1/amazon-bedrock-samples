import io
import os
import re
import json
import time
import boto3
import base64
import streamlit as st

from requests import request
from sigv4 import SigV4HttpRequester

# Bedrock Variable
agentId = os.environ['BEDROCK_AGENT_ID']
agentAliasId = os.environ['BEDROCK_AGENT_ALIAS_ID']
sessionId = os.environ['SESSION_ID']
knowledgeBaseId = os.environ['BEDROCK_KB_ID']
dataSourceId = os.environ['BEDROCK_DS_ID']

# Other Resource Variables
knowledge_base_s3_bucket = os.environ['KB_BUCKET_NAME']

# agents = bedrock-agent-runtime.us-east-1.amazonaws.com
# knowledgebases = bedrock-agent.us-east-1.amazonaws.com
agent_url = f'https://bedrock-agent-runtime.us-east-1.amazonaws.com/agents/{agentId}/agentAliases/{agentAliasId}/sessions/{sessionId}/text'
kb_url = f'https://bedrock-agent.us-east-1.amazonaws.com/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/ingestionjobs/'
# AWS Session and Clients Instantiation
session = boto3.Session(region_name=os.environ['AWS_REGION'])
# agent_client = boto3.client('bedrock-agent-runtime')
# agent_client = boto3.client('bedrock-agent')
s3_client = boto3.client('s3',region_name=os.environ['AWS_REGION'],config=boto3.session.Config(signature_version='s3v4',))

# Streamlit CSS
custom_css = """
    <style>
        .text-with-bg {
            background-color: #1c2e4a; /* Change this to your desired background color */
            padding: 10px;
            border-radius: 5px;
        }
    </style>
"""

# Streamlit App Layout
st.title('Bedrock Insurance Agent')
st.subheader('Powered by coffee and Amazon Bedrock')
st.info("**DISCLAIMER:** This demo uses an Amazon Bedrock foundation model and not intended to collect any personally identifiable information (PII) from users. Please do not provide any PII when interacting with this demo. The content generated by this demo is for informational purposes only.")
idp_logo = "bedrock_logo.png"
st.sidebar.image(idp_logo, width=300, output_format='PNG')
st.sidebar.markdown(custom_css, unsafe_allow_html=True)
st.sidebar.subheader('**About this Demo**')
st.sidebar.markdown('<p class="text-with-bg">Bedrock Insurance Agent uses Agents and Knowledge Base for Amazon Bedrock to assist human Insurance agents by creating a new claim, sending pending document reminders for open claims, and gathering evidence on existing claims</p>', unsafe_allow_html=True)

# Helper Functions
def show_pdf(uploaded_file):
    if uploaded_file is not None:
        file_contents = uploaded_file.getvalue()

        # Convert the file content to base64
        base64_pdf = base64.b64encode(file_contents).decode('utf-8')
        
        # Display the PDF
        pdf_display = f'<iframe src="data:application/pdf;base64,{base64_pdf}" width="500" height="500" type="application/pdf"></iframe>'
        st.markdown(pdf_display, unsafe_allow_html=True)

# Invoke Agent
def bedrock_agent(query):
    if query is not None:

        agent_query = {
            "inputText": query,   
            "enableTrace": True,
        }

        # send request
        print("Invoking Agent with query: " + query)
        requester = SigV4HttpRequester()
        response = requester.send_signed_request(
            url=agent_url,
            method='POST',
            service='bedrock',
            headers={
                'content-type': 'application/json', 
                'accept': 'application/json',
            },
            region='us-east-1',
            body=json.dumps(agent_query)
        )

        # Check if 'generatedResponsePart' exists in the response
        if 'generatedResponsePart' in response:
            # Access and assign the value to a variable
            generated_response_part = response['generatedResponsePart']
            # Now, 'generated_response_part' holds the value of 'generatedResponsePart'
            print("generatedResponsePart = " + generated_response_part)  # Printing the value for demonstration
        else:
            print("generatedResponsePart not found in the response")
        
        # Parse sig4_request Response
        string = ""
        for line in response.iter_content():
            try:
                string += line.decode(encoding='utf-8')
            except:
                continue

        split_response = string.split(":message-type")
        last_response = split_response[-1]
        if "bytes" in last_response:
            encoded_last_response = last_response.split("\"")[3]
            decoded = base64.b64decode(encoded_last_response)
            final_response = decoded.decode('utf-8')
        else:
            part1 = string[string.find('finalResponse')+len('finalResponse":'):] 
            part2 = part1[:part1.find('"}')+2]
            final_response = json.loads(part2)['text']

        final_response = final_response.replace("\"", "")
        final_response = final_response.replace("{input:{value:", "")
        final_response = final_response.replace(",source:null}}", "")
        agent_response = final_response

        print("Agent Response:: " + agent_response)
        return agent_response

def update_knowledge_base(file_content, bucket_name, s3_file_name):
    print("Syncing Knowledge Base Data Source")

    try:
        # Wrap the bytes content in an in-memory file-like object
        file_obj = io.BytesIO(file_content)

        s3_client.upload_fileobj(file_obj, bucket_name, s3_file_name)
        st.success(f"File uploaded successfully to S3 bucket '{bucket_name}' as '{s3_file_name}'")
    except Exception as e:
        st.error(f"Error uploading file to S3: {e}")
    finally:
        file_obj.close()  # Close the file-like object after upload

    # Define HTTP request payload (StartIngestionJobRequestContent)
    description = "Programmatic update of Bedrock Knowledge Base Data Source"

    kb_update = {
        "description": description,   
    }

    # agent_client.start_ingestion_job(knowledgeBaseId=knowledgeBaseId, dataSourceId=dataSourceId, description=description)
    print("Starting Ingestion Job")
    requester = SigV4HttpRequester()
    response = requester.send_signed_request(
        url=kb_url,
        method='PUT',
        service='bedrock',
        headers={
            'content-type': 'application/json', 
            'accept': 'application/json',
        },
        region='us-east-1',
        body=json.dumps(kb_update)
    )    
    
    print("Finished Ingestion Job: " + str(response))
    return response


def main():
    # Main Execution Block
    if not "valid_inputs_received" in st.session_state:
        st.session_state["valid_inputs_received"] = False

    # --- Agent Q&A ---
    st.subheader('Agent for Amazon Bedrock - Question & Answering')
    query = st.text_input("User Input", value="", placeholder="What can the agent help you with?", label_visibility="visible")
    agent_response = None  # Initialize agent_response variable
    
    if st.session_state.get("previous_query") != query and query != "":
        agent_response = bedrock_agent(query)
        st.session_state["previous_query"] = query  # Update previous_query if query changes

    if agent_response is not None:
        st.write("Agent's Response:", agent_response)

    # --- Knowledge Base Update ---
    st.subheader("Knowledge Base for Amazon Bedrock - File Upload")
    uploaded_file = st.file_uploader("Upload Document", type=["pdf", "txt", "docx"])

    if uploaded_file is not None:
        with st.expander("Uploaded File üìÅ"):
            show_pdf(uploaded_file)

        file_details = {"FileName": uploaded_file.name, "FileType": uploaded_file.type}
        file_name = "knowledge-base-assets/" + file_details["FileName"]

        # Display the contents of the file (for text-based formats like txt, pdf, docx)
        if uploaded_file.type == "text/plain":
            text = uploaded_file.read()
            st.write("Content:")
            st.write(text.decode("utf-8"))  # Decode bytes to string for display

        print("Uploading document to Amazon S3")
        file_contents = uploaded_file.getvalue()
        update_knowledge_base(file_contents, knowledge_base_s3_bucket, file_name)

# Call the main function to run the app
if __name__ == "__main__":
    main()
